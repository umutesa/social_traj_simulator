<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Trajectory Prediction System</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        input, button, select {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
        }
        
        input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .visualization-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .canvas-container {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        #trajectoryCanvas {
            width: 100%;
            height: 600px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: #000;
            cursor: crosshair;
        }
        
        .info-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .metric-card {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
        
        .trajectory-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .trajectory-item {
            background: rgba(255,255,255,0.1);
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Social Trajectory Prediction System</h1>
            <p>Interactive simulation with social proximity zones and repulsive forces</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Proximity Zone Radius</label>
                <input type="range" id="proximityRadius" min="30" max="150" value="80">
                <span id="proximityValue">80px</span>
            </div>
            
            <div class="control-group">
                <label>Repulsion Strength</label>
                <input type="range" id="repulsionStrength" min="0.1" max="2.0" step="0.1" value="0.5">
                <span id="repulsionValue">0.5</span>
            </div>
            
            <div class="control-group">
                <label>Prediction Time (s)</label>
                <input type="range" id="predictionTime" min="1" max="10" step="0.5" value="3">
                <span id="predictionTimeValue">3s</span>
            </div>
            
            <div class="control-group">
                <label>Social Factor Weight</label>
                <input type="range" id="socialWeight" min="0" max="1" step="0.1" value="0.3">
                <span id="socialWeightValue">0.3</span>
            </div>
            
            <button id="addTrajectory">Add Random Trajectory</button>
            <button id="clearAll">Clear All</button>
            <button id="toggleAnimation">⏯ Toggle Animation</button>
        </div>
        
        <div class="visualization-container">
            <div class="canvas-container">
                <canvas id="trajectoryCanvas"></canvas>
            </div>
            
            <div class="info-panel">
                <h3> System Metrics</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <div class="metric-value" id="trajectoryCount">0</div>
                        <div>Active Trajectories</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="avgError">0.0</div>
                        <div>Avg Prediction Error</div>
                    </div>
                </div>
                
                <div class="legend">
                    <h4>Legend</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Current Position</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ecdc4;"></div>
                        <span>Predicted Position</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(255,255,0,0.3);"></div>
                        <span>Proximity Zone</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #95e1d3;"></div>
                        <span>Trajectory Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff9ff3;"></div>
                        <span>Repulsion Vector</span>
                    </div>
                </div>
                
                <div class="trajectory-list" id="trajectoryList">
                    <h4>Active Trajectories</h4>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Transform {
            constructor(x = 0, y = 0, theta = 0) {
                this.x = x;
                this.y = y;
                this.theta = theta;
            }
            
            multiply(other) {
                const cos_theta = Math.cos(this.theta);
                const sin_theta = Math.sin(this.theta);
                return new Transform(
                    this.x + cos_theta * other.x - sin_theta * other.y,
                    this.y + sin_theta * other.x + cos_theta * other.y,
                    this.theta + other.theta
                );
            }
            
            clone() {
                return new Transform(this.x, this.y, this.theta);
            }
        }
        
        class Velocity {
            constructor(vx = 0, vy = 0, omega = 0) {
                this.vx = vx;
                this.vy = vy;
                this.omega = omega;
            }
            
            magnitude() {
                return Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag > 0) {
                    return new Velocity(this.vx / mag, this.vy / mag, this.omega);
                }
                return new Velocity(0, 0, 0);
            }
            
            add(other) {
                return new Velocity(this.vx + other.vx, this.vy + other.vy, this.omega + other.omega);
            }
            
            scale(factor) {
                return new Velocity(this.vx * factor, this.vy * factor, this.omega * factor);
            }
        }
        
        class TrajectoryState {
            constructor(transform, velocity) {
                this.transform = transform;
                this.velocity = velocity;
                this.timestamp = Date.now();
                this.valid = true;
            }
            
            isValid() {
                return this.valid && this.velocity.magnitude() > 0.1;
            }
        }
        
        class SocialTrajectoryPredictor {
            constructor() {
                this.trajectories = new Map();
                this.proximityRadius = 80;
                this.repulsionStrength = 0.5;
                this.socialWeight = 0.3;
                this.nextId = 0;
            }
            
            addTrajectory(transform, velocity) {
                const id = this.nextId++;
                const state = new TrajectoryState(transform, velocity);
                this.trajectories.set(id, {
                    id: id,
                    currentState: state,
                    history: [state],
                    proximityZone: this.proximityRadius,
                    color: this.generateColor(id)
                });
                return id;
            }
            
            generateColor(id) {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8'];
                return colors[id % colors.length];
            }
            
            // Core constant velocity extrapolation based on your provided function
            extrapolateEstimate(transform, velocity, currentTime, targetTime) {
                const dt = (targetTime - currentTime) / 1000.0; // Convert to seconds
                
                // Create state transition matrix (simplified 2D version)
                const phi_ti = [
                    [1, 0, dt, 0],
                    [0, 1, 0, dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];
                
                // State vector [x, y, vx, vy]
                const state = [transform.x, transform.y, velocity.vx, velocity.vy];
                
                // Predict new state
                const newState = this.matrixVectorMultiply(phi_ti, state);
                
                // Add process noise (simplified covariance)
                const noise = this.sampleNoise(dt);
                newState[0] += noise[0];
                newState[1] += noise[1];
                
                const newTransform = new Transform(newState[0], newState[1], transform.theta);
                const newVelocity = new Velocity(newState[2], newState[3], velocity.omega);
                
                return new TrajectoryState(newTransform, newVelocity);
            }
            
            matrixVectorMultiply(matrix, vector) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < vector.length; j++) {
                        sum += matrix[i][j] * vector[j];
                    }
                    result.push(sum);
                }
                return result;
            }
            
            sampleNoise(dt) {
                const sigma = 0.1 * dt; // Process noise standard deviation
                return [
                    this.gaussianRandom() * sigma,
                    this.gaussianRandom() * sigma
                ];
            }
            
            gaussianRandom() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }
            
            // Build social graph and calculate distances
            buildSocialGraph() {
                const graph = new Map();
                const trajectoryArray = Array.from(this.trajectories.values());
                
                for (let i = 0; i < trajectoryArray.length; i++) {
                    for (let j = i + 1; j < trajectoryArray.length; j++) {
                        const traj1 = trajectoryArray[i];
                        const traj2 = trajectoryArray[j];
                        
                        const distance = this.calculateDistance(
                            traj1.currentState.transform,
                            traj2.currentState.transform
                        );
                        
                        if (distance < Math.max(traj1.proximityZone, traj2.proximityZone)) {
                            if (!graph.has(traj1.id)) graph.set(traj1.id, []);
                            if (!graph.has(traj2.id)) graph.set(traj2.id, []);
                            
                            graph.get(traj1.id).push({ id: traj2.id, distance: distance });
                            graph.get(traj2.id).push({ id: traj1.id, distance: distance });
                        }
                    }
                }
                
                return graph;
            }
            
            calculateDistance(transform1, transform2) {
                const dx = transform1.x - transform2.x;
                const dy = transform1.y - transform2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // Calculate repulsive force based on social proximity
            calculateRepulsiveForce(trajectoryId, socialGraph) {
                const trajectory = this.trajectories.get(trajectoryId);
                if (!trajectory || !socialGraph.has(trajectoryId)) {
                    return new Velocity(0, 0, 0);
                }
                
                const neighbors = socialGraph.get(trajectoryId);
                let totalForceX = 0;
                let totalForceY = 0;
                
                for (const neighbor of neighbors) {
                    const neighborTraj = this.trajectories.get(neighbor.id);
                    if (!neighborTraj) continue;
                    
                    const dx = trajectory.currentState.transform.x - neighborTraj.currentState.transform.x;
                    const dy = trajectory.currentState.transform.y - neighborTraj.currentState.transform.y;
                    const distance = neighbor.distance;
                    
                    if (distance > 0 && distance < trajectory.proximityZone) {
                        // Inverse square law for repulsion
                        const forceMagnitude = this.repulsionStrength * Math.pow(trajectory.proximityZone / distance, 2);
                        const forceX = (dx / distance) * forceMagnitude;
                        const forceY = (dy / distance) * forceMagnitude;
                        
                        totalForceX += forceX;
                        totalForceY += forceY;
                    }
                }
                
                return new Velocity(totalForceX, totalForceY, 0);
            }
            
            // Enhanced prediction with social factors
            predictTrajectory(trajectoryId, predictionTime) {
                const trajectory = this.trajectories.get(trajectoryId);
                if (!trajectory) return null;
                
                const currentTime = Date.now();
                const targetTime = currentTime + predictionTime * 1000;
                
                // Standard constant velocity prediction
                const baselineState = this.extrapolateEstimate(
                    trajectory.currentState.transform,
                    trajectory.currentState.velocity,
                    currentTime,
                    targetTime
                );
                
                // Add social factors
                const socialGraph = this.buildSocialGraph();
                const repulsiveForce = this.calculateRepulsiveForce(trajectoryId, socialGraph);
                
                // Combine baseline velocity with social forces
                const sociallyAdjustedVelocity = trajectory.currentState.velocity.add(
                    repulsiveForce.scale(this.socialWeight)
                );
                
                // Re-predict with adjusted velocity
                const socialState = this.extrapolateEstimate(
                    trajectory.currentState.transform,
                    sociallyAdjustedVelocity,
                    currentTime,
                    targetTime
                );
                
                return {
                    baseline: baselineState,
                    social: socialState,
                    repulsiveForce: repulsiveForce,
                    neighbors: socialGraph.get(trajectoryId) || []
                };
            }
            
            updateTrajectory(trajectoryId, newTransform, newVelocity) {
                const trajectory = this.trajectories.get(trajectoryId);
                if (!trajectory) return;
                
                const newState = new TrajectoryState(newTransform, newVelocity);
                trajectory.currentState = newState;
                trajectory.history.push(newState);
                
                // Keep history manageable
                if (trajectory.history.length > 50) {
                    trajectory.history.shift();
                }
            }
            
            removeTrajectory(trajectoryId) {
                this.trajectories.delete(trajectoryId);
            }
        }
        
        class VisualizationSystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.predictor = new SocialTrajectoryPredictor();
                this.animationId = null;
                this.isAnimating = false;
                this.predictionTime = 3.0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupControls();
            }
            
            setupCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = this.canvas.offsetWidth;
                    this.canvas.height = this.canvas.offsetHeight;
                });
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Generate random velocity
                    const angle = Math.random() * 2 * Math.PI;
                    const speed = 20 + Math.random() * 30;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    const transform = new Transform(x, y, angle);
                    const velocity = new Velocity(vx, vy, 0);
                    
                    this.predictor.addTrajectory(transform, velocity);
                    this.updateUI();
                });
            }
            
            setupControls() {
                document.getElementById('proximityRadius').addEventListener('input', (e) => {
                    this.predictor.proximityRadius = parseInt(e.target.value);
                    document.getElementById('proximityValue').textContent = e.target.value + 'px';
                });
                
                document.getElementById('repulsionStrength').addEventListener('input', (e) => {
                    this.predictor.repulsionStrength = parseFloat(e.target.value);
                    document.getElementById('repulsionValue').textContent = e.target.value;
                });
                
                document.getElementById('predictionTime').addEventListener('input', (e) => {
                    this.predictionTime = parseFloat(e.target.value);
                    document.getElementById('predictionTimeValue').textContent = e.target.value + 's';
                });
                
                document.getElementById('socialWeight').addEventListener('input', (e) => {
                    this.predictor.socialWeight = parseFloat(e.target.value);
                    document.getElementById('socialWeightValue').textContent = e.target.value;
                });
                
                document.getElementById('addTrajectory').addEventListener('click', () => {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const angle = Math.random() * 2 * Math.PI;
                    const speed = 20 + Math.random() * 30;
                    
                    const transform = new Transform(x, y, angle);
                    const velocity = new Velocity(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                    
                    this.predictor.addTrajectory(transform, velocity);
                    this.updateUI();
                });
                
                document.getElementById('clearAll').addEventListener('click', () => {
                    this.predictor.trajectories.clear();
                    this.updateUI();
                });
                
                document.getElementById('toggleAnimation').addEventListener('click', () => {
                    this.toggleAnimation();
                });
                
                // Start animation by default
                this.startAnimation();
            }
            
            startAnimation() {
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animate();
                }
            }
            
            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.isAnimating = false;
                }
            }
            
            toggleAnimation() {
                if (this.isAnimating) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }
            
            animate() {
                this.updateTrajectories();
                this.draw();
                
                if (this.isAnimating) {
                    this.animationId = requestAnimationFrame(() => this.animate());
                }
            }
            
            updateTrajectories() {
                const dt = 0.016; // ~60fps
                
                for (const [id, trajectory] of this.predictor.trajectories) {
                    // Update position based on velocity
                    const newX = trajectory.currentState.transform.x + trajectory.currentState.velocity.vx * dt;
                    const newY = trajectory.currentState.transform.y + trajectory.currentState.velocity.vy * dt;
                    
                    // Bounce off walls
                    let newVx = trajectory.currentState.velocity.vx;
                    let newVy = trajectory.currentState.velocity.vy;
                    
                    if (newX < 0 || newX > this.canvas.width) {
                        newVx = -newVx;
                    }
                    if (newY < 0 || newY > this.canvas.height) {
                        newVy = -newVy;
                    }
                    
                    const newTransform = new Transform(
                        Math.max(0, Math.min(this.canvas.width, newX)),
                        Math.max(0, Math.min(this.canvas.height, newY)),
                        trajectory.currentState.transform.theta
                    );
                    const newVelocity = new Velocity(newVx, newVy, trajectory.currentState.velocity.omega);
                    
                    this.predictor.updateTrajectory(id, newTransform, newVelocity);
                }
                
                this.updateUI();
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.drawGrid();
                
                // Draw social graph connections
                this.drawSocialGraph();
                
                // Draw trajectories
                for (const [id, trajectory] of this.predictor.trajectories) {
                    this.drawTrajectory(id, trajectory);
                }
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawSocialGraph() {
                const socialGraph = this.predictor.buildSocialGraph();
                this.ctx.strokeStyle = 'rgba(255,255,0,0.3)';
                this.ctx.lineWidth = 2;
                
                for (const [id, neighbors] of socialGraph) {
                    const trajectory = this.predictor.trajectories.get(id);
                    if (!trajectory) continue;
                    
                    for (const neighbor of neighbors) {
                        const neighborTraj = this.predictor.trajectories.get(neighbor.id);
                        if (!neighborTraj) continue;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(
                            trajectory.currentState.transform.x,
                            trajectory.currentState.transform.y
                        );
                        this.ctx.lineTo(
                            neighborTraj.currentState.transform.x,
                            neighborTraj.currentState.transform.y
                        );
                        this.ctx.stroke();
                    }
                }
            }
            
            drawTrajectory(id, trajectory) {
                const current = trajectory.currentState.transform;
                const prediction = this.predictor.predictTrajectory(id, this.predictionTime);
                
                // Draw proximity zone
                this.ctx.fillStyle = 'rgba(255,255,0,0.1)';
                this.ctx.strokeStyle = 'rgba(255,255,0,0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.arc(current.x, current.y, this.predictor.proximityRadius, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Draw trajectory history
                if (trajectory.history.length > 1) {
                    this.ctx.strokeStyle = trajectory.color + '60';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    
                    const start = trajectory.history[0];
                    this.ctx.moveTo(start.transform.x, start.transform.y);
                    
                    for (let i = 1; i < trajectory.history.length; i++) {
                        const point = trajectory.history[i];
                        this.ctx.lineTo(point.transform.x, point.transform.y);
                    }
                    this.ctx.stroke();
                }
                
                // Draw current position
                this.ctx.fillStyle = trajectory.color;
                this.ctx.beginPath();
                this.ctx.arc(current.x, current.y, 8, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw velocity vector
                this.ctx.strokeStyle = trajectory.color;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(current.x, current.y);
                this.ctx.lineTo(
                    current.x + trajectory.currentState.velocity.vx * 2,
                    current.y + trajectory.currentState.velocity.vy * 2
                );
                this.ctx.stroke();
                
                if (prediction) {
                    // Draw baseline prediction
                    this.ctx.fillStyle = 'rgba(78, 205, 196, 0.7)';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        prediction.baseline.transform.x,
                        prediction.baseline.transform.y,
                        6, 0, 2 * Math.PI
                    );
                    this.ctx.fill();
                    
                    // Draw social prediction
                    this.ctx.fillStyle = '#4ecdc4';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        prediction.social.transform.x,
                        prediction.social.transform.y,
                        8, 0, 2 * Math.PI
                    );
                    this.ctx.fill();
                    
                    // Draw repulsive force vector
                    if (prediction.repulsiveForce.magnitude() > 0.1) {
                        this.ctx.strokeStyle = '#ff9ff3';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(current.x, current.y);
                        this.ctx.lineTo(
                            current.x + prediction.repulsiveForce.vx * 10,
                            current.y + prediction.repulsiveForce.vy * 10
                        );
                        this.ctx.stroke();
                    }
                    
                    // Draw prediction line
                    this.ctx.strokeStyle = 'rgba(78, 205, 196, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(current.x, current.y);
                    this.ctx.lineTo(
                        prediction.social.transform.x,
                        prediction.social.transform.y
                    );
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Draw trajectory ID
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(
                    `T${id}`,
                    current.x + 12,
                    current.y - 12
                );
            }
            
            updateUI() {
                const trajectoryCount = this.predictor.trajectories.size;
                document.getElementById('trajectoryCount').textContent = trajectoryCount;
                
                // Calculate average prediction error (simplified)
                let totalError = 0;
                let errorCount = 0;
                
                for (const [id, trajectory] of this.predictor.trajectories) {
                    const prediction = this.predictor.predictTrajectory(id, 1.0); // 1 second prediction
                    if (prediction && trajectory.history.length > 5) {
                        // Compare with actual trajectory from 1 second ago
                        const pastState = trajectory.history[trajectory.history.length - 60] || trajectory.history[0];
                        const error = this.predictor.calculateDistance(
                            prediction.social.transform,
                            pastState.transform
                        );
                        totalError += error;
                        errorCount++;
                    }
                }
                
                const avgError = errorCount > 0 ? (totalError / errorCount).toFixed(1) : '0.0';
                document.getElementById('avgError').textContent = avgError;
                
                // Update trajectory list
                this.updateTrajectoryList();
            }
            
            updateTrajectoryList() {
                const listContainer = document.getElementById('trajectoryList');
                listContainer.innerHTML = '<h4>Active Trajectories</h4>';
                
                for (const [id, trajectory] of this.predictor.trajectories) {
                    const div = document.createElement('div');
                    div.className = 'trajectory-item';
                    
                    const prediction = this.predictor.predictTrajectory(id, this.predictionTime);
                    const speed = trajectory.currentState.velocity.magnitude().toFixed(1);
                    const neighborCount = prediction ? prediction.neighbors.length : 0;
                    const repulsionMagnitude = prediction ? prediction.repulsiveForce.magnitude().toFixed(2) : '0.00';
                    
                    div.innerHTML = `
                        <div style="color: ${trajectory.color}; font-weight: bold;">Trajectory ${id}</div>
                        <div>Speed: ${speed} px/s</div>
                        <div>Neighbors: ${neighborCount}</div>
                        <div>Repulsion: ${repulsionMagnitude}</div>
                        <div>Position: (${trajectory.currentState.transform.x.toFixed(0)}, ${trajectory.currentState.transform.y.toFixed(0)})</div>
                    `;
                    
                    listContainer.appendChild(div);
                }
            }
        }
        
        // Error Analysis and Comparison System
        class ErrorAnalysisSystem {
            constructor(predictor) {
                this.predictor = predictor;
                this.errorHistory = [];
                this.comparisonData = [];
            }
            
            calculatePredictionAccuracy(trajectoryId, timeHorizon) {
                const trajectory = this.predictor.trajectories.get(trajectoryId);
                if (!trajectory || trajectory.history.length < 10) return null;
                
                const results = {
                    baseline: [],
                    social: [],
                    timeHorizon: timeHorizon
                };
                
                // Test predictions at different time points in history
                for (let i = 10; i < trajectory.history.length - 1; i++) {
                    const testState = trajectory.history[i];
                    const actualState = trajectory.history[i + Math.min(timeHorizon * 10, trajectory.history.length - i - 1)];
                    
                    // Baseline prediction (constant velocity)
                    const baselineState = this.predictor.extrapolateEstimate(
                        testState.transform,
                        testState.velocity,
                        testState.timestamp,
                        testState.timestamp + timeHorizon * 1000
                    );
                    
                    // Social prediction
                    const socialGraph = this.predictor.buildSocialGraph();
                    const repulsiveForce = this.predictor.calculateRepulsiveForce(trajectoryId, socialGraph);
                    const adjustedVelocity = testState.velocity.add(
                        repulsiveForce.scale(this.predictor.socialWeight)
                    );
                    
                    const socialState = this.predictor.extrapolateEstimate(
                        testState.transform,
                        adjustedVelocity,
                        testState.timestamp,
                        testState.timestamp + timeHorizon * 1000
                    );
                    
                    // Calculate errors
                    const baselineError = this.predictor.calculateDistance(
                        baselineState.transform,
                        actualState.transform
                    );
                    
                    const socialError = this.predictor.calculateDistance(
                        socialState.transform,
                        actualState.transform
                    );
                    
                    results.baseline.push(baselineError);
                    results.social.push(socialError);
                }
                
                return results;
            }
            
            generateComparisonReport() {
                const report = {
                    timestamp: Date.now(),
                    trajectoryCount: this.predictor.trajectories.size,
                    averageErrors: {
                        baseline: 0,
                        social: 0,
                        improvement: 0
                    },
                    socialFactorEffectiveness: 0
                };
                
                let baselineTotal = 0;
                let socialTotal = 0;
                let validTrajectories = 0;
                
                for (const [id] of this.predictor.trajectories) {
                    const accuracy = this.calculatePredictionAccuracy(id, 2.0);
                    if (accuracy && accuracy.baseline.length > 0) {
                        const avgBaseline = accuracy.baseline.reduce((a, b) => a + b, 0) / accuracy.baseline.length;
                        const avgSocial = accuracy.social.reduce((a, b) => a + b, 0) / accuracy.social.length;
                        
                        baselineTotal += avgBaseline;
                        socialTotal += avgSocial;
                        validTrajectories++;
                    }
                }
                
                if (validTrajectories > 0) {
                    report.averageErrors.baseline = baselineTotal / validTrajectories;
                    report.averageErrors.social = socialTotal / validTrajectories;
                    report.averageErrors.improvement = 
                        ((report.averageErrors.baseline - report.averageErrors.social) / report.averageErrors.baseline) * 100;
                    
                    report.socialFactorEffectiveness = Math.max(0, Math.min(100, report.averageErrors.improvement));
                }
                
                return report;
            }
        }
        
        // Initialize the system
        document.addEventListener('DOMContentLoaded', () => {
            const visualizationSystem = new VisualizationSystem('trajectoryCanvas');
            const errorAnalysis = new ErrorAnalysisSystem(visualizationSystem.predictor);
            
            // Add some initial trajectories for demonstration
            setTimeout(() => {
                // Add a few sample trajectories
                for (let i = 0; i < 3; i++) {
                    const x = 100 + i * 200;
                    const y = 100 + i * 150;
                    const angle = (i * Math.PI) / 3;
                    const speed = 30 + i * 10;
                    
                    const transform = new Transform(x, y, angle);
                    const velocity = new Velocity(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                    
                    visualizationSystem.predictor.addTrajectory(transform, velocity);
                }
                
                visualizationSystem.updateUI();
            }, 1000);
            
            // Periodic error analysis
            setInterval(() => {
                const report = errorAnalysis.generateComparisonReport();
                console.log('Prediction Analysis Report:', report);
                
                // Update advanced metrics if trajectories exist
                if (report.trajectoryCount > 0) {
                    document.getElementById('avgError').textContent = report.averageErrors.social.toFixed(1);
                }
            }, 5000);
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        visualizationSystem.toggleAnimation();
                        break;
                    case 'c':
                        visualizationSystem.predictor.trajectories.clear();
                        visualizationSystem.updateUI();
                        break;
                    case 'r':
                        // Add random trajectory
                        const x = Math.random() * visualizationSystem.canvas.width;
                        const y = Math.random() * visualizationSystem.canvas.height;
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = 20 + Math.random() * 30;
                        
                        const transform = new Transform(x, y, angle);
                        const velocity = new Velocity(Math.cos(angle) * speed, Math.sin(angle) * speed, 0);
                        
                        visualizationSystem.predictor.addTrajectory(transform, velocity);
                        visualizationSystem.updateUI();
                        break;
                }
            });
            
            // Add help text
            const helpDiv = document.createElement('div');
            helpDiv.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 15px;
                border-radius: 8px;
                font-size: 12px;
                max-width: 250px;
            `;
            helpDiv.innerHTML = `
                <strong>Controls:</strong><br>
                • Click canvas to add trajectory<br>
                • Space: Toggle animation<br>
                • 'R': Add random trajectory<br>
                • 'C': Clear all trajectories<br>
                <br>
                <strong>Visualization:</strong><br>
                • Red dots: Current positions<br>
                • Cyan dots: Predicted positions<br>
                • Yellow circles: Proximity zones<br>
                • Pink arrows: Repulsion forces<br>
                • Dashed lines: Prediction paths
            `;
            document.body.appendChild(helpDiv);
        });
    </script>
</body>
</html>
